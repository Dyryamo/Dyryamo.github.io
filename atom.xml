<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学海无涯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-06T13:59:05.828Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr zhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python</title>
    <link href="http://yoursite.com/2018/08/06/python/"/>
    <id>http://yoursite.com/2018/08/06/python/</id>
    <published>2018-08-06T13:56:16.000Z</published>
    <updated>2018-08-06T13:59:05.828Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight elm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="categories" scheme="http://yoursite.com/categories/categories/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>net</title>
    <link href="http://yoursite.com/2018/08/06/net/"/>
    <id>http://yoursite.com/2018/08/06/net/</id>
    <published>2018-08-06T04:45:06.000Z</published>
    <updated>2018-08-07T00:34:14.784Z</updated>
    
    <content type="html"><![CDATA[<p>#数据链路层</p><p><em>链路是只从一个结点到相邻结点的一段物理线路，中间没有其他交换结点，而数据链路是指当需要在一条线路上传输数据时，处理必须有一条物理线路外，还必须有必要的通信协议来控制这些数据的传输（现在最常用的办法是使用网路适配器（既有硬件，也有软件）；来实现这些协议）</em></p><h2 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><pre><code>封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，能够根据首部和尾部的标记，识别到帧的开始和结束。网络层的IP数据报传送到数据链路层就成为了帧的数据部分。</code></pre><p><em>MTU最大传送单元(maximum transfer unit) 为了提高帧的传送效率使帧的数据部分长度尽可能的大于首部和尾部的长度，但要MTU</em></p><h4 id="帧定界符"><a href="#帧定界符" class="headerlink" title="帧定界符"></a>帧定界符</h4><pre><code>SOH （start of head）二进制00000001 EOT  (end of transmission) 二进制00000100在传输钟出现差错时，接收端能够根于SOH，EOT 进行取舍</code></pre><hr><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><h4 id="透明传输含义"><a href="#透明传输含义" class="headerlink" title="透明传输含义"></a>透明传输含义</h4><pre><code>由于帧的开始和结束标记是专门指明的控制字符，因此，所传输的数据中的任何8比特的组合一定不允许和定界符的控制字符的比特编码一样，否则会出现帧定界符错误</code></pre><h4 id="透明传输的实现方法–-字节填充"><a href="#透明传输的实现方法–-字节填充" class="headerlink" title="透明传输的实现方法– 字节填充"></a>透明传输的实现方法– 字节填充</h4><pre><code>发送端的数据链路层在数据中出现帧定界符时，在SOH或EOT前插一个转义字符ESC（00011011）接受端在吧数据上交网络层前删掉这个转义字符ESC如果数据钟有转义字符，则再在其前添加一个转义字符</code></pre><hr><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><h4 id="比特差错"><a href="#比特差错" class="headerlink" title="比特差错"></a>比特差错</h4><pre><code>比特差错是传输错误的一种，传输错误的比特占所传输比特总数的比率叫做误码率BER.</code></pre><h4 id="帧丢失，帧重复，帧乱序"><a href="#帧丢失，帧重复，帧乱序" class="headerlink" title="帧丢失，帧重复，帧乱序"></a>帧丢失，帧重复，帧乱序</h4><h4 id="循环冗余检测的检错技术-CRC-cycle-Redundancy-Check-CRC只能检查比特差错"><a href="#循环冗余检测的检错技术-CRC-cycle-Redundancy-Check-CRC只能检查比特差错" class="headerlink" title="循环冗余检测的检错技术 CRC (cycle Redundancy Check) CRC只能检查比特差错"></a>循环冗余检测的检错技术 CRC (cycle Redundancy Check) CRC只能检查比特差错</h4><pre><code>1.将多项式转化为二进制序列，由G（X） = X^4 + X^3 + 1可知二进制一种有五位，第4位、第三位和第零位分别为1，则序列为110012.多项式的位数位5，则在数据帧的后面加上5-1位0，数据帧变为101100110000，然后使用模2除法除以        除数11001，得到余数。3.将计算出来的CRC校验码添加在原始帧的后面，真正的数据帧为101100110100，再把这个数据帧发送到接收端。4.接收端收到数据帧后，用上面选定的除数，用模2除法除去，验证余数是否为0，如果为0，则说明数据帧没有出错。</code></pre><p><img src="/2018/08/06/net/CRC.png" alt="CRC"></p><hr><h2 id="适配器，转发器，集线器，网桥，以太网交换几的作用以及使用场合"><a href="#适配器，转发器，集线器，网桥，以太网交换几的作用以及使用场合" class="headerlink" title="适配器，转发器，集线器，网桥，以太网交换几的作用以及使用场合"></a>适配器，转发器，集线器，网桥，以太网交换几的作用以及使用场合</h2><hr><h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol><li>结点A 的数据链路层吧网络层交下来的IP数据报添加首部和尾部封装成帧</li><li>结点A 把封装好的帧发送给结点B的数据链路层</li><li>若结点B 的数据链路层收到的帧无差错，则从收到的帧中提取ip数据报上交给网络层，否则丢弃此帧</li></ol><hr><h3 id="ppp-协议"><a href="#ppp-协议" class="headerlink" title="ppp 协议"></a>ppp 协议</h3><h4 id="ppp协议的需求"><a href="#ppp协议的需求" class="headerlink" title="ppp协议的需求"></a>ppp协议的需求</h4><pre><code>1.简单2.封装成帧3.透明性4.多种网络层协议5.多种类型链路6.差错控制7.检查链接状态8.最大传输单元9.网络地址协商10.数据压缩协商</code></pre><h3 id="ppp协议的组成"><a href="#ppp协议的组成" class="headerlink" title="ppp协议的组成"></a>ppp协议的组成</h3><pre><code>1.数据链路层协议可以用于异步穿行或同步串行的介质2.它使用LCP（link control protocol)链路控制协议 建立并维护数据链路链接3.NCP (network control protocol) 网络控制协议允许点到点链接上使用多种网络层协议</code></pre><hr><h3 id="ppp协议的帧格式"><a href="#ppp协议的帧格式" class="headerlink" title="ppp协议的帧格式"></a>ppp协议的帧格式</h3><h4 id="ppp协议的帧格式，图解"><a href="#ppp协议的帧格式，图解" class="headerlink" title="ppp协议的帧格式，图解"></a>ppp协议的帧格式，图解</h4><p><img src="/2018/08/06/net/ppp_protocol.png" alt="ppp协议的帧"></p><h4 id="ppp-协议帧格式个字段的意义"><a href="#ppp-协议帧格式个字段的意义" class="headerlink" title="ppp 协议帧格式个字段的意义"></a>ppp 协议帧格式个字段的意义</h4><pre><code>1.F ： 标记字段 规定为0x7E ,标记开始和结束，因此标记字段就是ppp帧的定界符2.A : 地址字段，规定为0xFF（最初曾考虑对这两个字段的值进行其他定义，而然至今未给出）3.C :控制字段，PPP首部的第四个字段是2个字节的协议字段4.FCS : CRC的帧检验序列FCS。       　1.当协议字段为0x0021时，PPP帧的信息字段就是IP数据报，    　2.当为0xC021时，则信息字段是PPP链路控制协议LCP的数据，    　3.当为0x8021表示这个网络层的控制数据    　4.0xC023 表示为安全性认证PAP    　5.0xC025 表示LQR    　6.0xC233 安全性认证认证CHAP </code></pre><h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><p>###特点</p><h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#数据链路层&lt;/p&gt;
&lt;p&gt;&lt;em&gt;链路是只从一个结点到相邻结点的一段物理线路，中间没有其他交换结点，而数据链路是指当需要在一条线路上传输数据时，处理必须有一条物理线路外，还必须有必要的通信协议来控制这些数据的传输（现在最常用的办法是使用网路适配器（既有硬件，也有软件）；来
      
    
    </summary>
    
    
      <category term="-net" scheme="http://yoursite.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="http://yoursite.com/2018/08/05/linux/"/>
    <id>http://yoursite.com/2018/08/05/linux/</id>
    <published>2018-08-05T04:45:23.000Z</published>
    <updated>2018-08-06T05:50:24.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim-常用命令"><a href="#vim-常用命令" class="headerlink" title="vim 常用命令"></a>vim 常用命令</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><pre><code>H 移动到屏幕最上方一行的第一个字符M 移动到屏幕最中央一行的第一个字符L 移动到屏幕最下方一行的第一个字符w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。b 向后移动一个单词 2b 向后移动2个单词e，同w，只不过是光标停在单词尾部ge，同b，光标停在单词尾部。^ 移动到本行第一个非空白字符上。0（数字0）移动到本行第一个字符上，&lt;HOME&gt; 移动到本行第一个字符。同0健。$ 移动到行尾 3$ 移动到下面3行的行尾gg 移动到文件头。 = [[G（shift + g） 移动到文件尾。 = ]]f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。F 同f，反向查找。跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre><code>u 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做（Redo），即撤销的撤销。</code></pre><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><pre><code>x 删除当前字符3x 删除当前光标开始向后三个字符X 删除当前字符的前一个字符。X=dhdl 删除当前字符， dl=xdh 删除前一个字符dd 删除当前行dj 删除上一行dk 删除下一行10d 删除当前行开始的10行。D 删除当前字符至行尾。D=d$d$ 删除当前字符之后的所有字符（本行）kdgg 删除当前行之前所有行（不包括当前行）jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）:1,10d 删除1-10行:11,$d 删除11行及以后所有的行:1,$d 删除所有行J(shift + j)　　删除两行之间的空行，实际上是合并两行。</code></pre><h1 id="tar-的常用方法"><a href="#tar-的常用方法" class="headerlink" title="tar 的常用方法"></a>tar 的常用方法</h1><pre><code>-tar -c新建打包文件,-x 压缩解压缩-j bzip2压缩解压缩-z gzip压缩解压缩-v 显示文件名-f 后接被处理的文件名tar -cjvf --tar -xjvf --</code></pre><h1 id="linux下解压windows文件乱码问题"><a href="#linux下解压windows文件乱码问题" class="headerlink" title="linux下解压windows文件乱码问题"></a>linux下解压windows文件乱码问题</h1><pre><code>unzip -O Cp936 xxx.zip</code></pre><h1 id="firewall"><a href="#firewall" class="headerlink" title="firewall:"></a>firewall:</h1><p><em>使用命令行管理firewall之前，说明有关于防火墙的策略独立性：明确的策略，策略之间无关联。 比如mysql使用3306，firewall添加mysql服务但未添加3306，当查询3306端口状态会显示no； 同理，添加3306端口，但未添加mysql服务，当查询mysql服务是否被firewalld允许时，显示no。在这两种情况下，外网都可以正常访问，也必须能访问，这里的逻辑不存在问题。同样，拿Java程序开发来类比：往hashMap.put进service与port，当get的时候就成了两码事,即便所操作的是关于mysql服务</em></p><p>#防火墙常用的命令</p><h3 id="1-查看防火墙状态"><a href="#1-查看防火墙状态" class="headerlink" title="1.查看防火墙状态"></a>1.查看防火墙状态</h3><pre><code>systemctl status firewalld</code></pre><h3 id="2-查看开放的服务-端口："><a href="#2-查看开放的服务-端口：" class="headerlink" title="2.查看开放的服务/端口："></a>2.查看开放的服务/端口：</h3><pre><code>firewall-cmd --list-servicefirewall-cmd --list-port</code></pre><h3 id="3-查询指定的端口是否永久开放"><a href="#3-查询指定的端口是否永久开放" class="headerlink" title="3.查询指定的端口是否永久开放"></a>3.查询指定的端口是否永久开放</h3><pre><code>firewall-cmd --permanent --query-port=1000/tcp</code></pre><h3 id="4-查询指定的服务-端口："><a href="#4-查询指定的服务-端口：" class="headerlink" title="4.查询指定的服务/端口："></a>4.查询指定的服务/端口：</h3><pre><code>firewall-cmd --query-service sshfirewall-cmd --query-port=3306/tcp</code></pre><h3 id="5-添加服务："><a href="#5-添加服务：" class="headerlink" title="5.添加服务："></a>5.添加服务：</h3><pre><code>firewall-cmd --permanent --add-service=ftpfirewall-cmd --permanent --remove-service=ftp</code></pre><h3 id="6-添加端口"><a href="#6-添加端口" class="headerlink" title="6.添加端口"></a>6.添加端口</h3><pre><code>方式1：  firewall-cmd --permanent --add-port=3306/tcp  firewall-cmd --permanent --add-port=1522/tcp  firewall-cmd --reload方式2：  cp  /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/ssh.xml  vi  /etc/firewalld/services/ssh.xml  vi /etc/firewalld/zones/public.xml</code></pre><h3 id="7-查看存在的zones"><a href="#7-查看存在的zones" class="headerlink" title="7.查看存在的zones:"></a>7.查看存在的zones:</h3><pre><code>firewall-cmd --get-zones</code></pre><h3 id="8-当前使用的zone："><a href="#8-当前使用的zone：" class="headerlink" title="8.当前使用的zone："></a>8.当前使用的zone：</h3><pre><code>firewall-cmd --get-active-zones</code></pre><h3 id="9-zone为public的所有策略："><a href="#9-zone为public的所有策略：" class="headerlink" title="9.zone为public的所有策略："></a>9.zone为public的所有策略：</h3><pre><code>firewall-cmd --zone=public --list-all</code></pre><h3 id="10-设置默认的zone-（public是最合适的，也是firewall默认的）"><a href="#10-设置默认的zone-（public是最合适的，也是firewall默认的）" class="headerlink" title="10.设置默认的zone: （public是最合适的，也是firewall默认的）"></a>10.设置默认的zone: （public是最合适的，也是firewall默认的）</h3><pre><code>firewall-cmd --set-default-zone=public</code></pre><p>#结果终端提示:无法获得锁/var/lib/dpkg/lock</p><pre><code>结果终端提示:无法获得锁/var/lib/dpkg/lockE: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？”解决办法如下：1.终端输入 ps  -aux ，列出进程,找到含有apt-get的进程，直接sudo kill PID解决。2.强制解锁--命令:sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim-常用命令&quot;&gt;&lt;a href=&quot;#vim-常用命令&quot; class=&quot;headerlink&quot; title=&quot;vim 常用命令&quot;&gt;&lt;/a&gt;vim 常用命令&lt;/h1&gt;&lt;h2 id=&quot;移动&quot;&gt;&lt;a href=&quot;#移动&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="categories" scheme="http://yoursite.com/categories/categories/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>algorithm</title>
    <link href="http://yoursite.com/2018/08/05/algorithm/"/>
    <id>http://yoursite.com/2018/08/05/algorithm/</id>
    <published>2018-08-05T04:44:07.000Z</published>
    <updated>2018-08-12T08:48:57.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-暑期培训"><a href="#2018-暑期培训" class="headerlink" title="2018 暑期培训"></a>2018 暑期培训</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><pre><code>引用维基百科的定义：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。（1）每个顶点出现且只出现一次；（2）若A在序列中排在B的前面，则在图中不存在从B到A的路径。也可以定义为：    拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。可以理解为工程的完成先后或者一些课程的先修课程</code></pre><h3 id="拓扑排序算法过程"><a href="#拓扑排序算法过程" class="headerlink" title="拓扑排序算法过程"></a>拓扑排序算法过程</h3><pre><code>1.检查无环图中所有点的入度，将入度为0的顶点保存2.将第一步求出来的顶点的所有相邻顶点的入度减一，相当于将此点删除,3.重复检查无环图钟的入度4若得到的结果集的顶点数小于图的顶点数，则说明图中有环(有环必然存在有顶点的度始终不为0)</code></pre><h3 id="拓扑排序例题"><a href="#拓扑排序例题" class="headerlink" title="拓扑排序例题"></a>拓扑排序例题</h3><h4 id="poj1094"><a href="#poj1094" class="headerlink" title="poj1094"></a>poj1094</h4><p><img src="/2018/08/05/algorithm/poj1094.png" alt="poj1094"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">Sample</span> Input</span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line">A&lt;<span class="keyword">B</span></span><br><span class="line"><span class="keyword">A&lt;C</span></span><br><span class="line"><span class="keyword">B&lt;C</span></span><br><span class="line"><span class="keyword">C&lt;D</span></span><br><span class="line"><span class="keyword">B&lt;D</span></span><br><span class="line"><span class="keyword">A&lt;B</span></span><br><span class="line"><span class="keyword">3 </span><span class="number">2</span></span><br><span class="line">A&lt;<span class="keyword">B</span></span><br><span class="line"><span class="keyword">B&lt;A</span></span><br><span class="line"><span class="keyword">26 </span><span class="number">1</span></span><br><span class="line">A&lt;Z</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">Sample</span> Output</span><br><span class="line"></span><br><span class="line"><span class="symbol">Sorted</span> sequence determined after <span class="number">4</span> relations: ABCD.</span><br><span class="line"><span class="symbol">Inconsistency</span> found after <span class="number">2</span> relations.</span><br><span class="line"><span class="symbol">Sorted</span> sequence cannot <span class="keyword">be </span>determined.</span><br></pre></td></tr></table></figure><h4 id="poj1094-代码"><a href="#poj1094-代码" class="headerlink" title="poj1094 代码"></a>poj1094 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">int</span> indexs[N];</span><br><span class="line"><span class="keyword">int</span> vex ,arc;</span><br><span class="line"><span class="keyword">int</span> queues[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(indexs,<span class="number">0</span>,<span class="keyword">sizeof</span>(indexs));</span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getindexs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vex ;i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vex ;j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[j][i] == <span class="number">1</span>)&#123;</span><br><span class="line">indexs[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">getindexs();</span><br><span class="line"><span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vex ;i ++)&#123;</span><br><span class="line"><span class="keyword">int</span> mm = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> loc = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; vex ;j ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(indexs[j] == <span class="number">0</span>)&#123;</span><br><span class="line">mm++;</span><br><span class="line">loc = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mm== <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;<span class="comment">//有环 </span></span><br><span class="line"><span class="keyword">if</span>(mm &gt; <span class="number">1</span>)</span><br><span class="line">flag = <span class="number">-1</span>;<span class="comment">//无法判别 </span></span><br><span class="line"><span class="keyword">if</span>(loc != <span class="number">-1</span>)&#123;</span><br><span class="line">indexs[loc] = <span class="number">-1</span>;</span><br><span class="line">queues[rear++] =  loc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; vex ;j ++ )&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[loc][j]==<span class="number">1</span>)&#123;</span><br><span class="line">indexs[j]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  flag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> head,tail;</span><br><span class="line"><span class="keyword">int</span> flag ;</span><br><span class="line"><span class="keyword">bool</span> fs = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">char</span> swa ;</span><br><span class="line"><span class="keyword">bool</span> flags = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;vex,&amp;arc),vex || arc)&#123;</span><br><span class="line">flags = <span class="literal">false</span>;</span><br><span class="line">getchar();</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arc ; i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(indexs,<span class="number">0</span>,<span class="keyword">sizeof</span>(indexs));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c%c%c%c"</span>,&amp;head,&amp;swa,&amp;tail,&amp;swa);</span><br><span class="line"><span class="built_in">map</span>[head-<span class="string">'A'</span>][tail-<span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line"> flag = toposort();</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Inconsistency found after %d relations.\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;arc;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c%c%c%c"</span>,&amp;head,&amp;swa,&amp;tail,&amp;swa);</span><br><span class="line">flags = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Sorted sequence determined after %d relations: "</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vex;j++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>,queues[j]+<span class="string">'A'</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">".\n"</span>);;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;arc;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c%c%c%c"</span>,&amp;head,&amp;swa,&amp;tail,&amp;swa);</span><br><span class="line">flags = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flags)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Sorted sequence cannot be determined.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="最小生成树概念"><a href="#最小生成树概念" class="headerlink" title="最小生成树概念"></a>最小生成树概念</h3><pre><code>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边</code></pre><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">随着如今社会的不断变化，交通问题也变得越来越重要，所以市长决定建设一些公路来方便各个城市之间的贸易和交易。</span><br><span class="line">虽然市长的想法很好，但是他也遇到了一般人也经常头疼的问题，那就是手头的经费有限……</span><br><span class="line">在规划过程中，设计师们已经预算出部分城市之间建设公路的经费需求。</span><br><span class="line">现在市长想知道，它能不能将他的m个城市在有限的经费内实现公路交通。</span><br><span class="line">如果可以的话，输出Yes，否则输出No（两个城市不一定要直接的公路相连，间接公路到达也可以。）</span><br><span class="line">输入描述:</span><br><span class="line"></span><br><span class="line">测试输入包含多条测试数据</span><br><span class="line">每个测试数据的第1行分别给出可用的经费c(&lt;1000000)，道路数目n(n&lt;10000)，以及城市数目m(&lt;100)。</span><br><span class="line">接下来的n行给出建立公路的成本信息，每行给出三个整数，分别是相连的两个城市v1、v2(0&lt;v1,v2&lt;=m)以及</span><br><span class="line">建设公路所需的成本h(h&lt;100)。</span><br><span class="line">输出描述:</span><br><span class="line"></span><br><span class="line">对每个测试用例，输出Yes或No。</span><br><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">20<span class="number"> 10 </span>5</span><br><span class="line">1<span class="number"> 2 </span>6</span><br><span class="line">1<span class="number"> 3 </span>3</span><br><span class="line">1<span class="number"> 4 </span>4</span><br><span class="line">1<span class="number"> 5 </span>5</span><br><span class="line">2<span class="number"> 3 </span>7</span><br><span class="line">2<span class="number"> 4 </span>7</span><br><span class="line">2<span class="number"> 5 </span>8</span><br><span class="line">3<span class="number"> 4 </span>6</span><br><span class="line">3<span class="number"> 5 </span>9</span><br><span class="line">4<span class="number"> 5 </span>2</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">Yes</span><br><span class="line">示例2</span><br><span class="line">输入</span><br><span class="line"></span><br><span class="line">10<span class="number"> 2 </span>2</span><br><span class="line">1<span class="number"> 2 </span>5</span><br><span class="line">1<span class="number"> 2 </span>15</span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="prim-解法"><a href="#prim-解法" class="headerlink" title="prim 解法"></a>prim 解法</h3><h4 id="prim算法的思想"><a href="#prim算法的思想" class="headerlink" title="prim算法的思想"></a>prim算法的思想</h4><pre><code>1.从图中的一个起点a开始，把a加入U集合2.寻找从与a有关联的边中权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，把b加入到集合U中，3.然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，重复操作</code></pre><h4 id="prim-解法代码"><a href="#prim-解法代码" class="headerlink" title="prim 解法代码"></a>prim 解法代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个人懒得写代码</span><br></pre></td></tr></table></figure><h4 id="Kruskal-解法"><a href="#Kruskal-解法" class="headerlink" title="Kruskal 解法"></a>Kruskal 解法</h4><h4 id="Kruskal算法思想"><a href="#Kruskal算法思想" class="headerlink" title="Kruskal算法思想"></a>Kruskal算法思想</h4><pre><code>1.先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，2.从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，反之，若该条边的两个顶点已落在同一棵树上，则不可取，3.应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。</code></pre><h4 id="Kruskal-解法代码"><a href="#Kruskal-解法代码" class="headerlink" title="Kruskal 解法代码"></a>Kruskal 解法代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kruskal</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10050</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,weight;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> c,vex,arc;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> head,<span class="keyword">int</span> tail,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">p[top].u = head;</span><br><span class="line">p[top].v = tail;</span><br><span class="line">p[top++].weight = weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp; x,<span class="keyword">const</span> node &amp; y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.weight &lt; y.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">finds</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(father[x] == x)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> father[x] = finds(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans =  <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">sort(p,p + top ,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; top ;i ++ )&#123;</span><br><span class="line"><span class="keyword">int</span> x = finds(p[i].u);</span><br><span class="line"><span class="keyword">int</span> y = finds(p[i].v);</span><br><span class="line"><span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">father[x] = y;</span><br><span class="line">ans += p[i].weight;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt == vex <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt &lt; vex <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; N ;i ++)&#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("3.in","r",stdin);</span></span><br><span class="line"><span class="keyword">int</span> head,tail,weight;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;c,&amp;arc,&amp;vex))&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arc ; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;head,&amp;tail,&amp;weight);</span><br><span class="line">addedge(head,tail,weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag = kruskal();</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">-1</span> || c &lt; flag)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><pre><code>DescriptionYou are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.Is an escape possible? If yes, how long will it take?InputThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a &apos;#&apos; and empty cells are represented by a &apos;.&apos;. Your starting position is indicated by &apos;S&apos; and the exit by the letter &apos;E&apos;. There&apos;s a single blank line after each level. Input is terminated by three zeroes for L, R and C.OutputEach maze generates one line of output. If it is possible to reach the exit, print a line of the form    Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the line    Trapped! Sample Input3 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0Sample OutputEscaped in 11 minute(s).Trapped!</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#define N 35</span><br><span class="line">using namespace std;</span><br><span class="line">int map[N][N][N];</span><br><span class="line"></span><br><span class="line">struct point&#123;</span><br><span class="line">int x, y, z,level;</span><br><span class="line"><span class="attribute">point()&#123;</span></span><br><span class="line">&#125; </span><br><span class="line">point(int xx, int yy,  int  zz , int levellevl)&#123;</span><br><span class="line">x =xx; y =yy ; z = zz; level = levellevl;</span><br><span class="line">&#125;</span><br><span class="line">void operator = (point&amp; other)&#123;</span><br><span class="line">x = other.x;</span><br><span class="line">y = other.y;</span><br><span class="line">z = other.z;</span><br><span class="line">level = other.level;</span><br><span class="line">&#125;</span><br><span class="line">bool operator == (point&amp; other)&#123;</span><br><span class="line">return x == other.x &amp;&amp; y == other.y &amp;&amp; z == other.z;</span><br><span class="line">&#125;</span><br><span class="line">&#125;start,end;</span><br><span class="line">int l,r,c;</span><br><span class="line">int dx[] = &#123;1,0,0,-1,0,0&#125;;</span><br><span class="line">int dy[] = &#123;0,1,0,0,-1,0&#125;;</span><br><span class="line">int dz[] = &#123;0,0,1,0,0,-1&#125;; </span><br><span class="line"><span class="attribute">set&lt;int&gt;visit;</span></span><br><span class="line">int bfs(point s, point e)&#123;</span><br><span class="line"><span class="attribute">queue&lt;point&gt;q;</span></span><br><span class="line">q.push(s);</span><br><span class="line"><span class="attribute">while(!q.empty())&#123;</span></span><br><span class="line">point front  = q.front();</span><br><span class="line">q.pop(); </span><br><span class="line">if(front == e)&#123;</span><br><span class="line">return front.level;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0 ; i &lt; 6 ;i ++ )&#123;</span><br><span class="line">if( (front.x + dx[i] &lt; l &amp;&amp; front.x + dx[i] &gt;= 0 ) &amp;&amp;</span><br><span class="line">(front.y + dy[i] &lt; r &amp;&amp; front.y + dy[i] &gt;= 0) &amp;&amp;</span><br><span class="line">(front.z + dz[i] &lt; c &amp;&amp; front.z + dz[i] &gt;= 0) &amp;&amp; </span><br><span class="line"> map[front.x + dx[i]][front.y + dy[i]][front.z + dz[i]] )&#123;</span><br><span class="line"> //printf("-&gt;&gt; %d",visit.find((front.x +dx[i])* 10000 + (front.y + dy[i])  * 100 + front.z + dz[i]) == visit.end()) ;</span><br><span class="line">if(visit.find(( (front.x +dx[i])* 10000 + (front.y + dy[i])  * 100 + front.z + dz[i])) == visit.end())&#123;</span><br><span class="line">q.push(point(front.x + dx[i],front.y + dy[i],front.z + dz[i],front.level +1));</span><br><span class="line">visit.insert( (front.x +dx[i]) * 10000 + (front.y + dy[i])  * 100 + front.z + dz[i] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int deal(char tmp)&#123;</span><br><span class="line">switch (tmp)&#123;</span><br><span class="line">case '#': return 0;</span><br><span class="line">case '.': </span><br><span class="line">case 'S':</span><br><span class="line">case 'E': return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void print()&#123;</span><br><span class="line">for(int i = 0 ; i &lt; l ;i ++)&#123;</span><br><span class="line">for(int j = 0 ; j &lt; r ;j ++)&#123;</span><br><span class="line">for( int z = 0 ; z &lt; c ; z ++)&#123;</span><br><span class="line">printf("%d ",map[i][j][z]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">printf("\n");</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line"><span class="attribute">memset(map,0,sizeof(map));</span></span><br><span class="line">visit.clear();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char tmp;</span><br><span class="line">while(scanf("%d%d%d",&amp;l,&amp;r,&amp;c) , ( l  || r  || c  ))&#123;</span><br><span class="line"><span class="attribute">init();</span></span><br><span class="line">for(int i = 0 ; i &lt; l ;i ++)&#123;</span><br><span class="line">for(int j = 0 ; j &lt; r ;j ++)&#123;</span><br><span class="line">for( int z = 0 ; z &lt; c ; z ++)&#123;</span><br><span class="line">scanf("%c",&amp;tmp);</span><br><span class="line">if(tmp == ' ' || tmp == '\n')&#123;</span><br><span class="line"><span class="attribute">z--;</span></span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">map[i][j][z] = deal(tmp);</span><br><span class="line">if(tmp == 'S')&#123;</span><br><span class="line">start.x = i; start.y = j; start.z = z;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp == 'E')&#123;</span><br><span class="line">end.x = i; end.y = j; end.z = z ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;bfs(start,end)&lt;&lt;endl;</span><br><span class="line">int ans = bfs(start,end);</span><br><span class="line">if(ans == -1)&#123;</span><br><span class="line"><span class="attribute">printf("Trapped!\n");</span></span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf("Escaped in %d minute(s).\n",ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><h3 id="差分约束基本讲解"><a href="#差分约束基本讲解" class="headerlink" title="差分约束基本讲解"></a>差分约束基本讲解</h3><p><img src="/2018/08/05/algorithm/差分约束1.png" alt="查分约束"><br><img src="/2018/08/05/algorithm/差分约束2.png" alt="查分约束"><br><img src="/2018/08/05/algorithm/差分约束3.png" alt="查分约束"></p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><pre><code>poj1201DescriptionYou are given n closed, integer intervals [ai, bi] and n integers c1, ..., cn.Write a program that:reads the number of intervals, their end points and integers c1, ..., cn from the standard input,computes the minimal size of a set Z of integers which has at least ci common elements with interval [ai, bi], for each i=1,2,...,n,writes the answer to the standard output.InputThe first line of the input contains an integer n (1 &lt;= n &lt;= 50000) -- the number of intervals. The following n lines describe the intervals. The (i+1)-th line of the input contains three integers ai, bi and ci separated by single spaces and such that 0 &lt;= ai &lt;= bi &lt;= 50000 and 1 &lt;= ci &lt;= bi - ai+1.OutputThe output contains exactly one integer equal to the minimal size of set Z sharing at least ci elements with interval [ai, bi], for each i=1,2,...,n.Sample Input53 7 38 10 36 8 11 3 110 11 1Sample Output6</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>令xi 为[0,xi]中的个数中整数点的个数则可以依据题目列出 s[bi] - s[ai-1] &gt;= ci再根据用查分系统可以想到用spfa 求解这一组不等式注意的是题目中应该还有 1=&gt;s[bi+1]-s[bi] &gt;=0 这个约束</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next,t ,w,s;</span><br><span class="line">&#125;e[<span class="number">3</span>*N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line"><span class="keyword">int</span> vex ,arc;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> w)</span></span>&#123; <span class="comment">// 伪链表 ， 头插法 </span></span><br><span class="line">e[top].s = s; </span><br><span class="line">e[top].t = t;</span><br><span class="line">e[top].w = w;</span><br><span class="line">e[top].next = head[s];</span><br><span class="line">head[s] = top++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> source)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;s; </span><br><span class="line">dis[source] = <span class="number">0</span>;</span><br><span class="line">visit[source]= <span class="literal">true</span>;</span><br><span class="line">s.push(source); </span><br><span class="line"><span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> front  = s.front();</span><br><span class="line">visit[front] = <span class="literal">false</span>;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">int</span> p = head[front];</span><br><span class="line"><span class="keyword">while</span> (p != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[e[p].t] &gt; dis[e[p].s] + e[p].w)&#123;</span><br><span class="line">dis[e[p].t] =  dis[e[p].s] + e[p].w;</span><br><span class="line"><span class="keyword">if</span>(!visit[e[p].t])&#123;</span><br><span class="line">s.push(e[p].t);</span><br><span class="line">visit[e[p].t] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p = e[p].next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxs,mins ; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line">fill(dis,dis+N,<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">maxs = <span class="number">-1</span>;</span><br><span class="line">mins = <span class="number">1</span>&lt;&lt;<span class="number">30</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a , b, c;</span><br><span class="line"><span class="comment">//freopen("input.txt","r",stdin);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">addedge(b+<span class="number">1</span>,a,-c);</span><br><span class="line">maxs = max(b+<span class="number">1</span>,maxs);</span><br><span class="line">mins = min(a,mins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = mins;i &lt; maxs ; i++)&#123;</span><br><span class="line">addedge(i+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">addedge(i,i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">spfa(maxs);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> ,-dis[mins] );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p><em>这里只提四种常见的算法，分别是dijkstra，Floyd，bellman_ford,spfa</em></p><h3 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h3><h4 id="dijkstra-策略"><a href="#dijkstra-策略" class="headerlink" title="dijkstra 策略"></a>dijkstra 策略</h4><pre><code>dijkstra 采用了一种贪心策略定义了最短路径集合，当发现一个已经是最短路径的顶点是，则将这个顶点加入到最短路径的集合中。当算法做到最短路径集合中包含全部顶点是，则算法结束</code></pre><h4 id="dijkstra-例题"><a href="#dijkstra-例题" class="headerlink" title="dijkstra 例题"></a>dijkstra 例题</h4><pre><code>后续补齐</code></pre><h4 id="dijstra-代码"><a href="#dijstra-代码" class="headerlink" title="dijstra 代码"></a>dijstra 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同样后续补齐</span><br></pre></td></tr></table></figure><h3 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman_ford"></a>bellman_ford</h3><h4 id="bellman-ford-例题"><a href="#bellman-ford-例题" class="headerlink" title="bellman_ford 例题"></a>bellman_ford 例题</h4><pre><code>后续补齐</code></pre><h4 id="bellman-ford-代码"><a href="#bellman-ford-代码" class="headerlink" title="bellman_ford 代码"></a>bellman_ford 代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同样后续补齐</span><br></pre></td></tr></table></figure><h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><h4 id="spfa-策略"><a href="#spfa-策略" class="headerlink" title="spfa 策略"></a>spfa 策略</h4><pre><code>bellman_ford 的队列优化版本相比较bellman_ford 需要对每一条边进行松弛而言，spfa只需要对已知的最短路进行松弛，因此效率提高。但是，当图特别稠密时，spfa也就退化和bellman_ford 一样</code></pre><h4 id="spfa-例题"><a href="#spfa-例题" class="headerlink" title="spfa 例题"></a>spfa 例题</h4><pre><code>虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中还能丰富自己的阅历，还可以看美丽的风景……所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车Input输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)接着的第T+1行有S个数，表示和草儿家相连的城市；接着的第T+2行有D个数，表示草儿想去地方。Output输出草儿能去某个喜欢的城市的最短时间。Sample Input6 2 31 3 51 4 72 8 123 8 44 9 129 10 21 28 9 10Sample Output9</code></pre><h4 id="spfa-代码"><a href="#spfa-代码" class="headerlink" title="spfa 代码"></a>spfa 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10050</span></span><br><span class="line"><span class="keyword">int</span> T ,S,D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,t,w,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> vex,arc;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;want;</span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    fill(dis,dis + N ,<span class="number">1</span>&lt;&lt; <span class="number">30</span>);</span><br><span class="line">    want.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    e[top].s = a;</span><br><span class="line">    e[top].t = b;</span><br><span class="line">    e[top].w = weight;</span><br><span class="line">    e[top].next = head[a];    </span><br><span class="line">    head[a] = top++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vex ;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; arc ; j ++)&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(dis[e[j].t]&gt; dis [e[j].s] + e[j].w)&#123;</span><br><span class="line">                    dis[e[j].t] = dis [e[j].s] + e[j].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    s.push(<span class="number">0</span>);</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> front = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        visit[front] = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">int</span> p = head[front];</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[e[p].t]&gt; dis[e[p].s] + e[p].w)&#123;</span><br><span class="line">                dis[e[p].t] = dis[e[p].s] + e[p].w;</span><br><span class="line">                <span class="keyword">if</span>(!visit[e[p].t])</span><br><span class="line">                &#123;</span><br><span class="line">                    s.push(e[p].t);</span><br><span class="line">                    visit[e[p].t] = <span class="literal">true</span>;    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            p = e[p].next; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = want.begin() ; it != want.end() ;it ++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dis[(*it)] &lt; min)</span><br><span class="line">            min = dis[(*it)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b , time;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;T,&amp;S,&amp;D)!=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; T ;i ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;time);</span><br><span class="line">            addedge(a,b,time);</span><br><span class="line">            addedge(b,a,time);</span><br><span class="line">            vex = max(vex,max(a,b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i&lt; S ; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b);</span><br><span class="line">            addedge(b,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            addedge(<span class="number">0</span>,b,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; D ; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b);</span><br><span class="line">            want.push_back(b);</span><br><span class="line">        &#125;    </span><br><span class="line">        arc = T + S;        </span><br><span class="line">        <span class="comment">//bellman_ford();</span></span><br><span class="line">        spfa();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="莫比乌斯引入"><a href="#莫比乌斯引入" class="headerlink" title="莫比乌斯引入"></a>莫比乌斯引入</h3><pre><code>先看一个函数     $$\sum_{i=0}^{n}$  \prod_\epsilon$$</code></pre><hr><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="高斯消元方法和主元的处理"><a href="#高斯消元方法和主元的处理" class="headerlink" title="高斯消元方法和主元的处理"></a>高斯消元方法和主元的处理</h3><p><em>高斯消元法，是线性代数中的一个算法，可用来求解线性方程组，并可以求出矩阵的秩，以及求出可逆方阵的逆矩阵</em><br><em>高斯消元法的原理是</em>：若用初等行变换将增广矩阵 化为 ，则AX = B与CX = D是同解方程组<br>高斯消元的注意事项：</p><ol><li>主元的处理：<br><em>因为在计算机中有效数字有限，这会导致计算机计算的结果出现比较大的偏差，下面看一个例子</em></li></ol><pre><code>0.0001x1+x2=1x1+x2=2解为x1=10000/9999, x2=9998/9999但是高斯消元会出现 （1-10000)x2=2-10000因为有效数字有限，计算机的浮点减法处理时可能把1及2弄没了，于是 得到0.0001x1+x2=1-10000x2=-10000,解为x2=1,x1=0, 显然不对。为了避免这个问题，应交换方程的位置，使得主元在这一列中最大X1 +x2=20.0001x1+x2=1但是高斯消元会出现 （1-0.0001)x2=1-0.0002计算机的浮点减法处理时也可能把0.0001及0.0002弄没了，于是 得到x1+x2=2x2=1,解为x2=1,x1=1,为了避免精度问题，我们可以在写程序的时候可以将当前行与主元绝对值最大的行交换，既不影响结果，也避免了精度问题</code></pre><p><img src="/2018/08/05/algorithm/Guass.png" alt="高斯消元"></p><h3 id="高斯消元例题"><a href="#高斯消元例题" class="headerlink" title="高斯消元例题"></a>高斯消元例题</h3><pre><code>题目大意：有 N 盏灯，M 个开关，每个开关可以控制多盏灯，每盏灯可以被多盏开关控制。开始每盏灯都是开闭状态，给定每盏灯的最终状态，问有多少种方案可以到达。</code></pre><h3 id="思路提示"><a href="#思路提示" class="headerlink" title="思路提示"></a>思路提示</h3><pre><code>1、因为有n盏灯，m个开关，对于每一盏灯可以列一个等式。对每一个开关可以看做一个变量。在列出这些之后可以得到一个增广矩阵。得到增广矩阵之后我们就很自然的得到解的情况，即无解，和有解的情况，由线性代数的知识可以得到     自由变量 = 变量的个数 – 秩(有解情况下系数矩阵的秩 = 增广矩阵的秩)又因为灯只有两种情况 ， 所以方案数 =  2^自由变量的个数</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 55</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">bool</span> maxtrix[N][N], copymaxtrix[N][N];</span><br><span class="line">ll n , m ; <span class="comment">// 矩阵的行数，和列数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"---------------------Debug----------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt;=n ; i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ;j &lt;= m+<span class="number">1</span>;j ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,copymaxtrix[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"---------------------end Debug----------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll r = <span class="number">0</span>; <span class="comment">// r 为矩阵的秩 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m ;i ++)&#123; <span class="comment">// 从第一列开始，处理主元 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = r+<span class="number">1</span> ;j &lt;= n; j++ ) &#123;</span><br><span class="line"><span class="keyword">if</span>(copymaxtrix[j][i])&#123; <span class="comment">// 找到这一列中，不为 0 的数，将此行与当前行替换 </span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ;k &lt;= m+<span class="number">1</span> ;k ++ )&#123;</span><br><span class="line">swap(copymaxtrix[r+<span class="number">1</span>][k],copymaxtrix[j][k]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print();</span></span><br><span class="line"><span class="keyword">if</span>(!copymaxtrix[r+<span class="number">1</span>][i])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n ;j ++ )&#123;</span><br><span class="line"><span class="keyword">if</span>(r+<span class="number">1</span> != j &amp;&amp; copymaxtrix[j][i])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= m +<span class="number">1</span> ;k ++ )&#123;</span><br><span class="line">copymaxtrix[j][k] ^= copymaxtrix[r+<span class="number">1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print();</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;"Debug -&gt; "&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span> ;i &lt;= n ;i ++ )&#123;</span><br><span class="line"><span class="keyword">if</span>(copymaxtrix[i][m+<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  m - r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> tmpsum, index;</span><br><span class="line"><span class="keyword">int</span> query;</span><br><span class="line"><span class="comment">//freopen("./input.txt","r",stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T ;cas ++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">"%d%d"</span> , &amp;n ,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>( maxtrix,<span class="number">0</span>,<span class="keyword">sizeof</span>(maxtrix));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span> ;i &lt;= m ; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmpsum);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tmpsum ;j ++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;index);</span><br><span class="line">maxtrix[index][i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"Case %d:\n"</span>,cas);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;query);</span><br><span class="line"><span class="keyword">while</span>( query -- )&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt;= n ;i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m; j++)&#123;</span><br><span class="line">copymaxtrix[i][j] = maxtrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span> ;i &lt;= n ;i ++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmpsum);</span><br><span class="line">copymaxtrix[i][m+<span class="number">1</span>] = tmpsum;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print();</span></span><br><span class="line">ll ans = Gauss();</span><br><span class="line"><span class="keyword">if</span>(ans == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ll)<span class="number">1</span>&lt;&lt;ans);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code>今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</code></pre><h4 id="互质版"><a href="#互质版" class="headerlink" title="互质版"></a>互质版</h4><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><pre><code>假设题中所有的除数都是互质的1、x = 2 mod 3 2、x = 3 mod 53、x = 2 mod 7首先先求出 3， 5 ， 7 的最小公倍数，得105，再将 105 除以 1式中的余数，则生35.此35可以整除除了1式之外的所有式子，且不能整除1式，将 35 mod 3 得到 一个余数 .    记    4、 35 = 2 mod 3  。对比1式，如果我们4、式同时乘 1式中的余数 / 4 式中的余数。同理对其他式子进行一样的操作（注：实际代码中并不是这样作的，而是通过逆元而得到，具体见下）    则最后得到的即为结果总结一下 所以，问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。也就是先求出5和7的公倍数模3下的逆元，再用逆元去乘余数。</code></pre><h4 id="公式（互质版）"><a href="#公式（互质版）" class="headerlink" title="公式（互质版）"></a>公式（互质版）</h4><p><img src="/2018/08/05/algorithm/中国剩余定理.jpeg" alt="中国剩余定理"></p><h4 id="非互质版"><a href="#非互质版" class="headerlink" title="非互质版"></a>非互质版</h4><pre><code>当题中的除数不是互质的时候，上述互质的方法就不满足使用的条件了。因此，我们需要通过方程合并，将方程合并成为一个方程</code></pre><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>图片来自网络<br><img src="/2018/08/05/algorithm/CRT.png" alt="CRT"></p><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><pre><code>Choose k different positive integers a1, a2, …, ak.For some non-negative m, divide it by every ai (1 ≤ i ≤ k) to find the remainder ri. If a1, a2, …, ak are properly chosen, m can be determined,then the pairs (ai, ri) can be used to express m.“It is easy to calculate the pairs from m, ” said Elina. “But how can I find m from the pairs?”Since Elina is new to programming, this problem is too difficult for her. Can you help her?</code></pre><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10050</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL k;</span><br><span class="line">LL a[N], r[N];</span><br><span class="line"><span class="function">LL <span class="title">ex_gcd</span><span class="params">(LL x, LL y, LL &amp;u, LL &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        u = <span class="number">1</span>;</span><br><span class="line">        v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LL d = ex_gcd(y, x % y, u, v);</span><br><span class="line">        LL tmp = u;</span><br><span class="line">        u = v;</span><br><span class="line">        v = tmp - x / y * v;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ins</span><span class="params">(LL x, LL y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//get x^-1 mod y</span></span><br><span class="line">    LL u, v;</span><br><span class="line">    LL d = ex_gcd(x, y, u, v);</span><br><span class="line">    <span class="keyword">if</span> (d != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (u % y + y) % y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ex_CRT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL a0 = a[<span class="number">0</span>], r0 = r[<span class="number">0</span>]; <span class="comment">// init;</span></span><br><span class="line">    LL k1, k2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a1 = a[i], r1 = r[i];</span><br><span class="line">        LL d = ex_gcd(r0, r1, k1, k2);</span><br><span class="line">        LL c = a1 - a0;</span><br><span class="line">        <span class="keyword">if</span> ((c % d))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c = ((c % r1) + r1) % r1;</span><br><span class="line">            c /= d;</span><br><span class="line">            r0 /= d;</span><br><span class="line">            r1 /= d;</span><br><span class="line">            c *= ins(r0, r1);</span><br><span class="line">            <span class="comment">//  LL t = r0 * r1 * d;</span></span><br><span class="line">            c %= r1;</span><br><span class="line">            c = (c * r0 * d);</span><br><span class="line">            c += a0;</span><br><span class="line">            r0 = r0 * r1 * d;</span><br><span class="line">            a0 = (c % r0 + r0) % r0;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// printf("%lld %lld\n", a0, r0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (a0 % r0 + r0) % r0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (LL i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;r[i], &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ex_CRT());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018-暑期培训&quot;&gt;&lt;a href=&quot;#2018-暑期培训&quot; class=&quot;headerlink&quot; title=&quot;2018 暑期培训&quot;&gt;&lt;/a&gt;2018 暑期培训&lt;/h1&gt;&lt;h2 id=&quot;拓扑排序&quot;&gt;&lt;a href=&quot;#拓扑排序&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2018/08/05/markdown/"/>
    <id>http://yoursite.com/2018/08/05/markdown/</id>
    <published>2018-08-05T04:38:22.000Z</published>
    <updated>2018-08-06T05:50:13.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>马克编辑器</strong> 是一个全功能的 <code>markdown</code> 编辑器，它包含了以下特性：</p><ol><li>创建，编辑和预览 <code>markdown</code> 文档。</li><li>将你的文档同步到 <strong>Dropbox</strong>。</li><li>将你的文档通过 Email 发送给其他人。</li></ol><p>这个编辑器使用 <code>markdown</code> 语法，让你能够创造格式漂亮的文档。这个语法非常简单，和你使用纯为本几乎没什么区别。</p><h2 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><hr><p>在行首输入 1－6 个 <code>#</code> 符号。符号的个数决定了标题的层级：</p><h1 id="1级标题"><a href="#1级标题" class="headerlink" title="1级标题"></a>1级标题</h1><h2 id="2级标题"><a href="#2级标题" class="headerlink" title="2级标题"></a>2级标题</h2><h3 id="3级标题"><a href="#3级标题" class="headerlink" title="3级标题"></a>3级标题</h3><h4 id="4级标题"><a href="#4级标题" class="headerlink" title="4级标题"></a>4级标题</h4><h5 id="5级标题"><a href="#5级标题" class="headerlink" title="5级标题"></a>5级标题</h5><h6 id="6级标题"><a href="#6级标题" class="headerlink" title="6级标题"></a>6级标题</h6><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><hr><p>加粗：</p><p><strong>加粗文本</strong></p><p>斜体：</p><p><em>斜体文本</em></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><hr><p><a href="http://example.com/" target="_blank" rel="noopener">链接文本</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><hr><p><img src="http://lkl.mx/img/EkZYGsPBg" alt="图片标题"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><hr><p>有序列表:</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>无序列表:</p><ul><li>列表项</li><li>列表项</li><li>列表项</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr><blockquote><p>Stay hungry, stay foolish.</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><hr><p>行内代码：<code>foo.go()</code> .</p><p>多行代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let app = <span class="string">"Markdown"</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Good"</span>)</span></span></span><br></pre></td></tr></table></figure></p><h3 id="缩紧代码"><a href="#缩紧代码" class="headerlink" title="缩紧代码"></a>缩紧代码</h3><hr><p>四个空格或者一个 Tab 表示缩进代码：</p><p>这是一个普通的段落。</p><pre><code>这是一个代码块</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><hr><p>简单的表格:</p><table><thead><tr><th>标题</th><th>标题</th><th>标题</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td><td>单元格</td></tr></tbody></table><p>你还可以添加一些边框：</p><table><thead><tr><th>标题</th><th>标题</th><th>标题</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td><td>单元格</td></tr></tbody></table><p>你可以控制单元格的对齐方式：</p><table><thead><tr><th style="text-align:left">标题</th><th style="text-align:center">标题</th><th style="text-align:right">标题</th></tr></thead><tbody><tr><td style="text-align:left">左</td><td style="text-align:center">中</td><td style="text-align:right">右</td></tr><tr><td style="text-align:left">左</td><td style="text-align:center">中</td><td style="text-align:right">右</td></tr></tbody></table><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><hr><p><del>Strikethrough</del></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><p>三种类型的分割线:</p><hr><hr><hr><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><hr><p>一 在行尾添加两个空格或者换行符代表换行：</p><p>这行的行尾油两个空格<br>这是一个新行。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;马克编辑器&lt;/strong&gt; 是一个全功能的 &lt;code&gt;markdown&lt;/code&gt; 编辑器，它包含了以
      
    
    </summary>
    
      <category term="categories" scheme="http://yoursite.com/categories/categories/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
</feed>
